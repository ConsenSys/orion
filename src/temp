const DotEnv = require('dotenv').config();
const EthereumTx = require('ethereumjs-tx').Transaction;
const Solc = require('solc');
const Fs = require('fs');
const Web3 = require('web3');
// Various config options
const numTxPerBlock = 5;
const blockCreationIntervalMs = parseInt(process.env.BLOCK_CREATION_INTERVAL_IN_MS);
const interTxSendIntervalMs = parseInt(process.env.INTER_TX_SEND_INTERVAL_IN_MS);
const createContract = parseInt(process.env.CREATE_CONTRACT);
const sendTransactions = parseInt(process.env.SEND_TRANSACTIONS);
const txNodeURL = process.env.BESU_TX_NODE_URL;
var perfTestAddress = process.env.BESU_CONTRACT_ADDRESS;
var exchangeAddress1 = process.env.EXCHANGE_ADDRESS_1;
var exchangeAddress2 = process.env.EXCHANGE_ADDRESS_2;
// Global variables
var currentNonce;
var numTxCreated = 0;
var perfTestContract;
var exchangeContract1;
var exchangeContract2;
var perfTestStateChangeCallData;
var exchangeStateChangeCallData;
var perfTestStateChangeCallGasEstimate;
var exchangeStateChangeCallGasEstimate;
var txGenerationInterval;
var latestCreatedContractAddress;
// Connect to Westlake Tx Node
var web3 = new Web3(new Web3.providers.HttpProvider(txNodeURL));
console.log("1");
function findImports(path) {
	console.log(path);
    return {
      contents: Fs.readFileSync(path, 'UTF-8')//'library L { function f() internal returns (uint) { return 7; } }'//Fs.readFileSync(path, 'UTF-8')
    };
}
// Compile PerfTest smart contract
var data = Fs.readFileSync('Besu.sol', 'UTF-8');
//console.log(data);
var inputs = {
  language: 'Solidity',
  sources: {
    'besu.sol': {
      content: data
    }
  },
  settings: {
    outputSelection: {
      '*': {
        '*': ['*']
      }
    }
  }
};
//var input = Fs.readFileSync('IDEX.sol', 'UTF-8');
console.log("2");
var output = JSON.parse(Solc.compile(JSON.stringify(inputs),{ import: findImports }));
console.log(output);
console.log(output.contracts['besu.sol']['SimpleStorage'].evm.bytecode.object);
console.log(output.contracts['besu.sol']['SimpleStorage'].abi);
const perfTestBytecode = output.contracts['besu.sol']['SimpleStorage'].evm.bytecode.object;
const perfTestAbi = output.contracts['besu.sol']['SimpleStorage'].abi;
/*
// Compile the mainnet exchange contract
input = Fs.readFileSync('MigrosHks.sol', 'UTF-8');
output = Solc.compile(input, 1);
const exchangeBytecode = output.contracts[':Exchange'].bytecode;
const exchangeAbi = JSON.parse(output.contracts[':Exchange'].interface);
*/
const accountAddress = process.env.ACCOUNT_ADDRESS_IN_HEX;
const privateKey = Buffer.from(process.env.PRIVATE_KEY_IN_HEX, 'hex');
const Common = require('ethereumjs-common').default;
const customCommon = Common.forCustomChain(
    'mainnet',
    {
        name: 'test',
        chainId: 220,
    },
    'constantinople',
);
// The slightly convoluted logic below is to ensure we don't send transactions before the contract is created
if (createContract) {
    initialContractCreation().then(function() {
        if (sendTransactions) {
            submitTransactions().catch((e) => {
                console.log('Failed to send transactions due to error: ' + e);
                process.exitCode = 1;
            });
        }
    }).catch((e) => {
        console.log('Failed to create contract due to error: ' + e);
        process.exitCode = 1;
    });
} else if (sendTransactions) {
    submitTransactions().catch((e) => {
        console.log('Failed to send transactions due to error: ' + e);
        process.exitCode = 1;
    });
} else {
    console.log('Neither CREATE_CONTRACT nor SEND_TRANSACTIONS was enabled so no action was taken');
    process.exitCode = 1;
}
async function initialContractCreation() {
    console.log('Fetching current nonce for account: ' + accountAddress);
    try {
        // Account setup
        var accountNonce = await web3.eth.getTransactionCount(accountAddress);
        console.log('Current account nonce is: ' + accountNonce);
        // Set up our perftest contract deployment parameters
        var deployContractCreationTxParams = {
            nonce: accountNonce,
            gasPrice: '0x00',
            gasLimit: '0x5B8D80',
			value: '0x00',
            data: '0x' + perfTestBytecode,
			restriction: 'restricted',
			privatefor:  ['zJbqJawVafSHSGnFv5QJThVA1OYCl69tBVMmpTvPlwg='],
			privateFrom: 'zJbqJawVafSHSGnFv5QJThVA1OYCl69tBVMmpTvPlwg='
        };
        // Deploy the perftest contract
        var deployContractCreationTx = new EthereumTx(deployContractCreationTxParams, { common: customCommon });
        deployContractCreationTx.sign(privateKey);
        console.log('Submitting perftest contract creation tx with tx params: ' + accountNonce);//JSON.stringify(deployContractCreationTxParams));
		console.log('DeploymentCode :  0x' + deployContractCreationTx.serialize().toString('hex'));
        //var receipt = await web3.eth.sendSignedTransaction('0x' + deployContractCreationTx.serialize().toString('hex'));
        //perfTestAddress = receipt.contractAddress;
        //latestCreatedContractAddress = perfTestAddress;
        //console.log('Perftest contract address is ' + perfTestAddress);
		//console.log('Perftest contract address is ' + receipt.transactionHash);
		//console.log('Perftest contract address is ' + receipt);
		//transactionHash
        //perfTestContract = new web3.eth.Contract(perfTestAbi, perfTestAddress);
        //perfTestStateChangeCallData = perfTestContract.methods.TestCall().encodeABI();
		console.log("Done");
    } catch(e) {
        console.log('Contract creation failed');
        throw e;
    }
}




